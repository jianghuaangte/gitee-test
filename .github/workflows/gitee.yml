name: Mirror and Replace GitHub Releases to Gitee

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'  # 每天自动运行一次

env:
  GITEE_API: https://gitee.com/api/v5

jobs:
  mirror-releases:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        repo:
          - "neovim/neovim"  # 替换为实际仓库
          - "vnt-dev/vnt"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          pip install requests pygithub python-gitee

      - name: Get latest GitHub release
        id: get_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          from github import Github
          import os, json, hashlib, subprocess

          repo_name = "${{ matrix.repo }}"
          safe_repo_name = repo_name.replace('/', '_')
          download_dir = f"downloads/{safe_repo_name}"
          
          # 清理并创建下载目录
          subprocess.run(["rm", "-rf", download_dir], check=False)
          os.makedirs(download_dir, exist_ok=True)
          
          # 获取GitHub最新release
          g = Github(os.getenv('GITHUB_TOKEN'))
          repo = g.get_repo(repo_name)
          release = repo.get_latest_release()
          
          # 下载资源文件
          assets_info = []
          for asset in release.get_assets():
            print(f"Downloading {asset.name}...")
            file_path = f"{download_dir}/{asset.name}"
            
            # 下载文件
            headers = {'Authorization': f'token {os.getenv("GITHUB_TOKEN")}'}
            with requests.get(asset.browser_download_url, headers=headers, stream=True) as r:
              r.raise_for_status()
              with open(file_path, 'wb') as f:
                for chunk in r.iter_content(chunk_size=8192):
                  f.write(chunk)
            
            # 计算SHA256
            sha256_hash = hashlib.sha256()
            with open(file_path, "rb") as f:
              for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
            file_hash = sha256_hash.hexdigest()
            
            # 处理大文件分割
            file_size = os.path.getsize(file_path)
            if file_size > 100 * 1024 * 1024:
              print(f"Splitting {asset.name}...")
              split_prefix = f"{file_path}.part"
              subprocess.run(["split", "-b", "100M", file_path, split_prefix])
              
              # 计算分割文件哈希
              split_files = sorted([f for f in os.listdir(download_dir) 
                                 if f.startswith(os.path.basename(split_prefix))])
              split_hashes = []
              for sf in split_files:
                sha256_hash = hashlib.sha256()
                with open(f"{download_dir}/{sf}", "rb") as f:
                  for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
                split_hashes.append(f"{sf}: {sha256_hash.hexdigest()}")
              
              assets_info.append({
                "type": "split",
                "original": asset.name,
                "hash": file_hash,
                "parts": split_files,
                "part_hashes": split_hashes
              })
            else:
              assets_info.append({
                "type": "single",
                "name": asset.name,
                "hash": file_hash
              })
          
          # 生成校验文件
          with open(f"{download_dir}/SHA256SUMS.txt", "w") as f:
            for item in assets_info:
              if item["type"] == "split":
                f.write(f"{item['original']}: {item['hash']}\n")
                f.write("\n".join(item["part_hashes"]) + "\n")
              else:
                f.write(f"{item['name']}: {item['hash']}\n")
          
          # 设置输出
          print(f"::set-output name=tag_name::{safe_repo_name}-{release.tag_name}")
          print(f"::set-output name=release_title::{repo_name} {release.tag_name}")
          print(f"::set-output name=release_body::{release.body}")
          print(f"::set-output name=assets_info::{json.dumps(assets_info)}")
          print(f"::set-output name=download_dir::{download_dir}")

      - name: Delete existing Gitee release
        run: |
          import requests, os
          
          tag_name = "${{ steps.get_release.outputs.tag_name }}"
          url = f"{os.getenv('GITEE_API')}/repos/${{ secrets.GITEE_OWNER }}/${{ secrets.GITEE_REPO }}/releases/tags/{tag_name}"
          
          # 检查release是否存在
          response = requests.get(
            url,
            headers={"Authorization": f"token ${{ secrets.GITEE_TOKEN }}"}
          )
          
          # 如果存在则删除
          if response.status_code == 200:
            release_id = response.json()["id"]
            requests.delete(
              f"{os.getenv('GITEE_API')}/repos/${{ secrets.GITEE_OWNER }}/${{ secrets.GITEE_REPO }}/releases/{release_id}",
              headers={"Authorization": f"token ${{ secrets.GITEE_TOKEN }}"}
            )
            print(f"Deleted existing release: {tag_name}")
          elif response.status_code == 404:
            print(f"No existing release found for {tag_name}")
          else:
            response.raise_for_status()

      - name: Create new Gitee release
        id: create_release
        uses: nicennnnnnnlee/action-gitee-release@v1.0.5
        with:
          gitee_owner: ${{ secrets.GITEE_OWNER }}
          gitee_repo: ${{ secrets.GITEE_REPO }}
          gitee_token: ${{ secrets.GITEE_TOKEN }}
          gitee_tag_name: ${{ steps.get_release.outputs.tag_name }}
          gitee_release_name: ${{ steps.get_release.outputs.release_title }}
          gitee_release_body: ${{ steps.get_release.outputs.release_body }}
          gitee_target_commitish: master
          gitee_file_path: ${{ steps.get_release.outputs.download_dir }}/SHA256SUMS.txt
          gitee_file_name: SHA256SUMS.txt

      - name: Upload all assets
        run: |
          import os, subprocess, json
          
          assets_info = json.loads('${{ steps.get_release.outputs.assets_info }}')
          download_dir = "${{ steps.get_release.outputs.download_dir }}"
          release_id = "${{ steps.create_release.outputs.release-id }}"
          
          for item in assets_info:
            if item["type"] == "split":
              for part in item["parts"]:
                print(f"Uploading {part}...")
                subprocess.run([
                  "curl", "-X", "POST",
                  "-H", "Authorization: token ${{ secrets.GITEE_TOKEN }}",
                  "-F", f"file=@{download_dir}/{part}",
                  f"{os.getenv('GITEE_API')}/repos/${{ secrets.GITEE_OWNER }}/${{ secrets.GITEE_REPO }}/releases/{release_id}/upload"
                ], check=True)
            else:
              print(f"Uploading {item['name']}...")
              subprocess.run([
                "curl", "-X", "POST",
                "-H", "Authorization: token ${{ secrets.GITEE_TOKEN }}",
                "-F", f"file=@{download_dir}/{item['name']}",
                f"{os.getenv('GITEE_API')}/repos/${{ secrets.GITEE_OWNER }}/${{ secrets.GITEE_REPO }}/releases/{release_id}/upload"
              ], check=True)
